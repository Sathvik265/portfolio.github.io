<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sathvik Kemtur - Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav>
        <a href="#home" class="active" onclick="showPage('home')">Home</a>
        <a href="#course-reflections" onclick="showPage('course-reflections')">Course Reflections</a>
        <a href="#project-reflections" onclick="showPage('project-reflections')">Project Reflections</a>
    </nav>

    <div id="home" class="page active">
        <header>
            <h1>Sathvik Kemtur</h1>
            <p>Transforming complex challenges into elegant solutions | Tech enthusiast & innovative problem-solver crafting the future one algorithm at a time | Let's build something extraordinary together </p>
        </header>
        <section>
            <h2>üöÄ Projects</h2>
            <ul>
                <li><strong>Smart Parking Management System</strong><br>
                    The Smart Parking Management System offers a technology-driven solution to the pressing problem of urban parking. Addressing challenges such as limited availability, traffic congestion, and inefficient allocation, the system automates parking management and provides real-time updates to optimize resource utilization. This project is motivated by the critical role of parking in urban infrastructure and the negative impact of parking problems on urban life. By leveraging technology, particularly graph algorithms, this system aims to create a more efficient and intelligent parking experience.
                </li>
            </ul>
            
            <h2>üíª Skills</h2>
            <ul>
                <li>C++, Python, HTML and R for statistics</li>
                <li>Data Structures and Algorithms</li>
            </ul>

            <h2>üåê Find Me Online</h2>
            <ul>
                <li><a href="https://github.com/Sathvik265" target="_blank">GitHub</a></li>
                <li><a href="https://www.linkedin.com/in/sathvik-kemtur-9553452a9/" target="_blank">LinkedIn</a></li>
            </ul>

            <h2>üìö Portfolio Details</h2>
            <dl>
                <div class="card">
                    <dt>Course: Design and Analysis of Algorithms (24ECS205)</dt>
                </div>
                <div class="card">
                    <dt>Student: Sathvik Kemtur (01FE23BCS143)</dt>
                </div>
                <div class="card">
                    <dt>Institution: KLE Technological University</dt>
                </div>
            </dl>
        </section>
    </div>

    <div id="course-reflections" class="page">
        <section>
            <h2>Course Reflections</h2>
            <ul>
                <li>
                    <strong>Course Overview</strong><br>
                    This course introduced foundational principles of algorithm design, optimization, and problem-solving techniques, equipping me with the skills to tackle complex computational challenges effectively and efficiently.
                </li>
                <li>
                    <strong>Learning Experience</strong><br>
                    The Design and Analysis of Algorithms course has provided me with a strong foundation in algorithmic thinking. I've learned to analyze problems systematically and design efficient solutions using various algorithmic paradigms.
                </li>
                <li>
                    <strong>Key Concepts Mastered</strong><br>
                    - Algorithm complexity analysis and Big O notation<br>
                    - Divide and conquer algorithms<br>
                    - Dynamic programming<br>
                    - Graph algorithms and their applications
                </li>
                <li>
                    <strong>Skills Development</strong><br>
                    This course has enhanced my problem-solving abilities and taught me to approach computational challenges with a structured mindset.
                </li>
            </ul>

            <section>
                <h2>Detailed Course Overview</h2>
                <p>This course introduced foundational principles of algorithm design, optimization, and problem-solving techniques, equipping me with the skills to tackle complex computational challenges effectively and efficiently.</p>

                <h3>Key Topics:</h3>
                <ul>
                    <li><strong>Binary Search Trees (BST)</strong>: Dynamic data structures for efficient data retrieval.</li>
                    <li><strong>Graph Traversals (DFS and BFS)</strong>: Techniques for exploring graph structures.</li>
                    <li><strong>Heap Structures</strong>: Efficiently accessing min/max elements.</li>
                    <li><strong>Sorting Algorithms</strong>: Understanding sorting techniques and their real-world use cases.</li>
                    <li><strong>Pattern Searching Algorithms</strong>: Efficiently searching for patterns in large datasets.</li>
                    <li><strong>Graph Algorithms</strong>: Dijkstra‚Äôs for shortest path and Kruskal‚Äôs for minimum spanning tree.</li>
                </ul>
            </section>
        </section>
    </div>

    <div id="project-reflections" class="page">
        <section>
            <h2>Project Reflections</h2>
            <ul>
                <li>
                    <strong>Project Overview</strong><br>
                    The Smart Parking Management System represents the practical application of algorithmic concepts learned in the course.
                </li>
                <li>
                    <strong>Technical Implementation</strong><br>
                    - Applied graph algorithms for optimal parking space allocation<br>
                    - Implemented real-time updating system<br>
                    - Created efficient data structures for parking management
                </li>
                <li>
                    <strong>Learning Outcomes</strong><br>
                    This project helped me understand the real-world application of algorithms and the importance of efficient system design.
                </li>
            </ul>
    
            <section>
                <h3>Reflections on Problem-Solving and Algorithm Design</h3>
                <ol>
                    <li>
                        <strong>How do you determine the most efficient approach when solving a complex problem?</strong><br>
                        To determine the most efficient approach:
                        <ul>
                            <li><strong>Analyze the Problem:</strong> Break it down to understand its constraints, input size, and expected output.</li>
                            <li><strong>Evaluate Algorithmic Options:</strong> Compare possible solutions based on their time and space complexities.</li>
                            <li><strong>Consider Constraints:</strong> For example, if real-time processing is required, prioritize time efficiency over space.</li>
                            <li><strong>Test Feasibility:</strong> Use sample inputs to ensure the algorithm handles edge cases effectively.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>What criteria do you use to evaluate the effectiveness of a solution?</strong><br>
                        <ul>
                            <li><strong>Efficiency:</strong> Does the solution run within acceptable time and space limits?</li>
                            <li><strong>Scalability:</strong> Can it handle large datasets or increased input sizes?</li>
                            <li><strong>Robustness:</strong> Does it work correctly across all edge cases?</li>
                            <li><strong>Maintainability:</strong> Is the code readable and easy to modify for future requirements?</li>
                            <li><strong>Simplicity:</strong> Avoid unnecessary complexity while meeting requirements.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Reflect on a situation where you need to balance multiple conflicting constraints in a design. What approach did you take?</strong><br>
                        <strong>Example:</strong> Designing an algorithm for a parking management system.<br>
                        <ul>
                            <li><strong>Conflicting Constraints:</strong> Real-time responsiveness (time efficiency) vs. accurate predictions based on large datasets (space efficiency).</li>
                            <li><strong>Approach:</strong>
                                <ul>
                                    <li>Used greedy algorithms for quick decisions on immediate scheduling.</li>
                                    <li>Employed dynamic programming for long-term optimizations, running in the background.</li>
                                    <li>Cached intermediate results to reduce redundant calculations.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <strong>How do you decide when to prioritize simplicity over optimization in a solution?</strong><br>
                        <ul>
                            <li><strong>Problem Context:</strong> If the problem is well-defined, small-scale, or needs rapid prototyping, simplicity is prioritized.</li>
                            <li><strong>Resource Constraints:</strong> Limited time or computational resources favor simple solutions.</li>
                            <li><strong>Future Scope:</strong> If a solution is likely to evolve, simplicity ensures maintainability.</li>
                        </ul>
                        <strong>Example:</strong> For a classroom project, I prioritize simplicity to ensure the solution is understandable and meets learning objectives.
                    </li>
                    <li>
                        <strong>Reflect on how breaking down a problem into smaller components can help you approach it more effectively.</strong><br>
                        <strong>Example:</strong> Implementing a dynamic programming solution for the Knapsack problem.<br>
                        <ul>
                            <li><strong>Breaking Down:</strong>
                                <ul>
                                    <li>Divided the problem into subproblems (smaller weight capacities and items).</li>
                                    <li>Solved each subproblem iteratively and used the results to build the final solution.</li>
                                </ul>
                            </li>
                            <li><strong>Benefits:</strong> Simplifies debugging, improves clarity, and helps identify patterns in the problem.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Reflect on the trade-offs while choosing between different approaches to solve a problem.</strong><br>
                        <strong>Example:</strong> Choosing between Merge Sort and Quick Sort.<br>
                        <ul>
                            <li><strong>Trade-Offs:</strong>
                                <ul>
                                    <li>Merge Sort is stable and predictable (O(n log n)) but uses more space (O(n)).</li>
                                    <li>Quick Sort is faster on average but has a worst-case time complexity of O(n¬≤).</li>
                                </ul>
                            </li>
                            <li><strong>Decision:</strong> For large datasets where stability matters, I choose Merge Sort; for in-memory operations with small datasets, Quick Sort is preferable.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>How do you identify and address potential limitations or weaknesses in a proposed solution?</strong><br>
                        <ul>
                            <li><strong>Stress Testing:</strong> Run the solution on edge cases and large datasets to identify weaknesses.</li>
                            <li><strong>Performance Profiling:</strong> Measure time and space usage to detect bottlenecks.</li>
                            <li><strong>Feedback:</strong> Seek peer reviews to catch overlooked issues.</li>
                            <li><strong>Refinement:</strong> Optimize code sections with the highest impact, such as reducing redundant operations.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>How do you decide when to innovate versus relying on tried-and-tested solutions?</strong><br>
                        <ul>
                            <li><strong>Problem Novelty:</strong> If a problem aligns closely with existing solutions, I start with tried-and-tested methods.</li>
                            <li><strong>Opportunity for Improvement:</strong> If existing methods fall short in efficiency or scalability, I innovate by adapting or creating new solutions.</li>
                        </ul>
                        <strong>Example:</strong> For navigating the nearest parking spot, I integrated the current location of the user into DIJKSTRA'S algorithm.
                    </li>
                </ol>
            </section>
        </section>
    </div>
    

    <script>
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            
            document.querySelectorAll('nav a').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + pageId) {
                    link.classList.add('active');
                }
            });
        }

        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section');
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top < window.innerHeight && rect.bottom >= 0) {
                    section.classList.add('visible');
                }
            });
        });
    </script>
</body>
</html>
